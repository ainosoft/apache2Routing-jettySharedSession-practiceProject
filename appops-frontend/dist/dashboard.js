/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/dashboard.js":
/*!**************************!*\
  !*** ./src/dashboard.js ***!
  \**************************/
/***/ (() => {

eval("{document.addEventListener('DOMContentLoaded', () => {\n  // Get userId from URL query params\n  let currentUserId = new URLSearchParams(window.location.search).get('userId');\n  if (!currentUserId) {\n    alert('User ID is required in the URL (e.g., ?userId=74)');\n    window.location.href = 'index.html';\n    return;\n  }\n\n  // Get user email from sessionStorage and compute initials\n  const userEmail = sessionStorage.getItem('userEmail') || '';\n  let initials = '';\n  if (userEmail) {\n    const parts = userEmail.split('@')[0].split(/[._]/); // split on . or _\n    if (parts.length === 1) {\n      initials = parts[0].substring(0, 2).toUpperCase();\n    } else {\n      initials = parts.map(p => p[0]).join('').substring(0, 2).toUpperCase();\n    }\n  } else {\n    initials = currentUserId.substring(0, 2).toUpperCase();\n  }\n\n  // UI setup\n  const userNameDisplay = document.getElementById('user-name-display');\n  const userInitialsDiv = document.getElementById('user-initials');\n  if (userNameDisplay) userNameDisplay.textContent = userEmail || currentUserId;\n  if (userInitialsDiv) userInitialsDiv.textContent = initials;\n\n  // Modal logic\n  window.openModal = (modalId) => { document.getElementById(modalId).classList.add('show'); };\n  window.closeModal = (modalId, event) => {\n    if (event && event.target !== document.getElementById(modalId) && !event.target.classList.contains('btn-neutral')) return;\n    document.getElementById(modalId).classList.remove('show');\n  };\n  document.addEventListener('keydown', (event) => {\n    if (event.key === 'Escape') {\n      document.querySelectorAll('.modal.show').forEach(modal => modal.classList.remove('show'));\n    }\n  });\n\n  // Notification\n  const showNotification = (message, type = 'success') => {\n    const notification = document.createElement('div');\n    notification.className = 'notification';\n    notification.textContent = message;\n    if (type === 'error') notification.classList.add('error');\n    document.body.appendChild(notification);\n    setTimeout(() => { notification.classList.add('show'); }, 10);\n    setTimeout(() => {\n      notification.classList.remove('show');\n      setTimeout(() => { document.body.removeChild(notification); }, 500);\n    }, 3000);\n  };\n\n  // Fetch organizations from backend\n  async function fetchOrganizations(userId) {\n    try {\n      const response = await fetch('/DeploymentManager/getAllTenantsOfUser?userId=' + encodeURIComponent(userId));\n      if (!response.ok) throw new Error('Failed to fetch organizations');\n      return await response.json();\n    } catch (e) {\n      showNotification('Failed to fetch organizations', 'error');\n      return [];\n    }\n  }\n\n  // Render organizations\n  async function renderOrganizations() {\n    const orgList = document.getElementById('orgList');\n    const organizations = await fetchOrganizations(currentUserId);\n    orgList.innerHTML = organizations.length > 0\n      ? organizations.map(org => `<div class=\"org-item\" onclick=\"selectItem('Organization', '${org.name}')\"><h4>${org.name}</h4></div>`).join('')\n      : `<p>No organizations found. Create one to get started.</p>`;\n    populateTenantDropdown(organizations);\n  }\n\n  // Create organization\n  window.createOrganization = async () => {\n    const name = document.getElementById('orgName').value.trim();\n    if (!name) { showNotification('Organization name is required.', 'error'); return; }\n    // Generate a unique incremental id for each new organization\n    let lastOrgId = Number(localStorage.getItem('lastOrgId') || '0');\n    const newOrgId = lastOrgId + 1;\n    localStorage.setItem('lastOrgId', newOrgId);\n    // Build request body for backend: full Tenant object inside 0.value\n    const parentId = Math.floor(Math.random() * 99) + 1; // 1 to 99\n    const body = {\n      0: { value: name },\n      1: { value: parentId },\n      2: { value: Number(currentUserId) },\n      3: { value: \"true\" }\n    };\n    try {\n      const response = await fetch('/DeploymentManager/createTenantSimple', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(body)\n      });\n      if (!response.ok) throw new Error('Failed to create organization');\n      showNotification(`Organization \\\"${name}\\\" created successfully!`);\n      document.getElementById('orgName').value = '';\n      closeModal('org-modal', { target: document.getElementById('org-modal') });\n      renderOrganizations();\n    } catch (e) {\n      showNotification('Failed to create organization', 'error');\n    }\n  };\n\n  // Populate tenant dropdown in service modal\n  function populateTenantDropdown(organizations = []) {\n    const select = document.getElementById('tenantSelection');\n    if (!select) return;\n    let options = '<option value=\"\">No organizations available</option>';\n    if (organizations.length > 0) {\n      options = '<option value=\"__personal__\">Use my personal tenant</option>';\n      options += organizations.map(org => `<option value=\"${org.tenantId}\">${org.name}</option>`).join('');\n    } else {\n      options = '<option value=\"__personal__\">Use my personal tenant</option>';\n    }\n    select.innerHTML = options;\n  }\n\n  // Fetch services from backend\n  async function fetchServices(userId) {\n    try {\n      const response = await fetch('/BuilderService/getAllIndesignServicesOfUser?0=' + encodeURIComponent(userId));\n      if (!response.ok) throw new Error('Failed to fetch services');\n      return await response.json();\n    } catch (e) {\n      showNotification('Failed to fetch services', 'error');\n      return [];\n    }\n  }\n\n  // Render services\n  async function renderServices() {\n    const serviceList = document.getElementById('serviceList');\n    const services = await fetchServices(currentUserId);\n    serviceList.innerHTML = services.length > 0\n      ? services.map(srv => `<div class=\"service-item\" onclick=\"selectItem('Service', '${srv.serviceName}')\"><h4>${srv.serviceName}</h4><p style=\"margin:0;color:var(--text-secondary);font-size:0.9rem;\">Version: v1.0.0</p></div>`).join('')\n      : `<p>No services found. Create one to get started.</p>`;\n  }\n\n  // Create service (implement as needed)\n  window.createService = async () => {\n    const serviceName = document.getElementById('serviceName').value.trim();\n    const tenantSelect = document.getElementById('tenantSelection');\n    const tenantId = tenantSelect ? tenantSelect.value : '';\n    if (!serviceName) {\n      showNotification('Service name is required.', 'error');\n      return;\n    }\n    let userIdToSend = tenantId;\n    if (!tenantId || tenantId === '__personal__') {\n      userIdToSend = currentUserId;\n    }\n    const body = {\n      0: { value: serviceName },\n      1: { value: userIdToSend }\n    };\n    try {\n      const response = await fetch('/BuilderService/createIndesignService', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(body)\n      });\n      if (!response.ok) throw new Error('Failed to create service');\n      showNotification(`Service \\\"${serviceName}\\\" created successfully!`);\n      document.getElementById('serviceName').value = '';\n      closeModal('service-modal', { target: document.getElementById('service-modal') });\n      renderServices();\n    } catch (e) {\n      showNotification('Failed to create service', 'error');\n    }\n  };\n\n  // Select item\n  window.selectItem = (type, name) => { showNotification(`Selected ${type}: ${name}`); };\n\n  // Initial render\n  renderOrganizations();\n  renderServices();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGFzaGJvYXJkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQ0FBcUM7QUFDNUQ7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBMEM7QUFDbkUsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFNBQVMsVUFBVSxTQUFTO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQTZEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyw4QkFBOEI7QUFDekMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBLE9BQU87QUFDUDtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0EsZ0NBQWdDLDhDQUE4QztBQUM5RTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYSxJQUFJLFNBQVM7QUFDdEYsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLGdCQUFnQixVQUFVLGdCQUFnQix3QkFBd0IsNEJBQTRCLGlCQUFpQjtBQUN4TTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQSxvQ0FBb0Msa0RBQWtEO0FBQ3RGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qyw2QkFBNkIsS0FBSyxJQUFJLEtBQUs7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHBvcHMtZnJvbnRlbmQvLi9zcmMvZGFzaGJvYXJkLmpzPzQyODIiXSwic291cmNlc0NvbnRlbnQiOlsiZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgLy8gR2V0IHVzZXJJZCBmcm9tIFVSTCBxdWVyeSBwYXJhbXNcbiAgbGV0IGN1cnJlbnRVc2VySWQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLmdldCgndXNlcklkJyk7XG4gIGlmICghY3VycmVudFVzZXJJZCkge1xuICAgIGFsZXJ0KCdVc2VyIElEIGlzIHJlcXVpcmVkIGluIHRoZSBVUkwgKGUuZy4sID91c2VySWQ9NzQpJyk7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnaW5kZXguaHRtbCc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gR2V0IHVzZXIgZW1haWwgZnJvbSBzZXNzaW9uU3RvcmFnZSBhbmQgY29tcHV0ZSBpbml0aWFsc1xuICBjb25zdCB1c2VyRW1haWwgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCd1c2VyRW1haWwnKSB8fCAnJztcbiAgbGV0IGluaXRpYWxzID0gJyc7XG4gIGlmICh1c2VyRW1haWwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHVzZXJFbWFpbC5zcGxpdCgnQCcpWzBdLnNwbGl0KC9bLl9dLyk7IC8vIHNwbGl0IG9uIC4gb3IgX1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGluaXRpYWxzID0gcGFydHNbMF0uc3Vic3RyaW5nKDAsIDIpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxzID0gcGFydHMubWFwKHAgPT4gcFswXSkuam9pbignJykuc3Vic3RyaW5nKDAsIDIpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGluaXRpYWxzID0gY3VycmVudFVzZXJJZC5zdWJzdHJpbmcoMCwgMikudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIC8vIFVJIHNldHVwXG4gIGNvbnN0IHVzZXJOYW1lRGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VyLW5hbWUtZGlzcGxheScpO1xuICBjb25zdCB1c2VySW5pdGlhbHNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXNlci1pbml0aWFscycpO1xuICBpZiAodXNlck5hbWVEaXNwbGF5KSB1c2VyTmFtZURpc3BsYXkudGV4dENvbnRlbnQgPSB1c2VyRW1haWwgfHwgY3VycmVudFVzZXJJZDtcbiAgaWYgKHVzZXJJbml0aWFsc0RpdikgdXNlckluaXRpYWxzRGl2LnRleHRDb250ZW50ID0gaW5pdGlhbHM7XG5cbiAgLy8gTW9kYWwgbG9naWNcbiAgd2luZG93Lm9wZW5Nb2RhbCA9IChtb2RhbElkKSA9PiB7IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTsgfTtcbiAgd2luZG93LmNsb3NlTW9kYWwgPSAobW9kYWxJZCwgZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICE9PSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKSAmJiAhZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYnRuLW5ldXRyYWwnKSkgcmV0dXJuO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgfTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW9kYWwuc2hvdycpLmZvckVhY2gobW9kYWwgPT4gbW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE5vdGlmaWNhdGlvblxuICBjb25zdCBzaG93Tm90aWZpY2F0aW9uID0gKG1lc3NhZ2UsIHR5cGUgPSAnc3VjY2VzcycpID0+IHtcbiAgICBjb25zdCBub3RpZmljYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBub3RpZmljYXRpb24uY2xhc3NOYW1lID0gJ25vdGlmaWNhdGlvbic7XG4gICAgbm90aWZpY2F0aW9uLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykgbm90aWZpY2F0aW9uLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3RpZmljYXRpb24pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4geyBub3RpZmljYXRpb24uY2xhc3NMaXN0LmFkZCgnc2hvdycpOyB9LCAxMCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBub3RpZmljYXRpb24uY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm90aWZpY2F0aW9uKTsgfSwgNTAwKTtcbiAgICB9LCAzMDAwKTtcbiAgfTtcblxuICAvLyBGZXRjaCBvcmdhbml6YXRpb25zIGZyb20gYmFja2VuZFxuICBhc3luYyBmdW5jdGlvbiBmZXRjaE9yZ2FuaXphdGlvbnModXNlcklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9EZXBsb3ltZW50TWFuYWdlci9nZXRBbGxUZW5hbnRzT2ZVc2VyP3VzZXJJZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHVzZXJJZCkpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggb3JnYW5pemF0aW9ucycpO1xuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzaG93Tm90aWZpY2F0aW9uKCdGYWlsZWQgdG8gZmV0Y2ggb3JnYW5pemF0aW9ucycsICdlcnJvcicpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciBvcmdhbml6YXRpb25zXG4gIGFzeW5jIGZ1bmN0aW9uIHJlbmRlck9yZ2FuaXphdGlvbnMoKSB7XG4gICAgY29uc3Qgb3JnTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcmdMaXN0Jyk7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9ucyA9IGF3YWl0IGZldGNoT3JnYW5pemF0aW9ucyhjdXJyZW50VXNlcklkKTtcbiAgICBvcmdMaXN0LmlubmVySFRNTCA9IG9yZ2FuaXphdGlvbnMubGVuZ3RoID4gMFxuICAgICAgPyBvcmdhbml6YXRpb25zLm1hcChvcmcgPT4gYDxkaXYgY2xhc3M9XCJvcmctaXRlbVwiIG9uY2xpY2s9XCJzZWxlY3RJdGVtKCdPcmdhbml6YXRpb24nLCAnJHtvcmcubmFtZX0nKVwiPjxoND4ke29yZy5uYW1lfTwvaDQ+PC9kaXY+YCkuam9pbignJylcbiAgICAgIDogYDxwPk5vIG9yZ2FuaXphdGlvbnMgZm91bmQuIENyZWF0ZSBvbmUgdG8gZ2V0IHN0YXJ0ZWQuPC9wPmA7XG4gICAgcG9wdWxhdGVUZW5hbnREcm9wZG93bihvcmdhbml6YXRpb25zKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBvcmdhbml6YXRpb25cbiAgd2luZG93LmNyZWF0ZU9yZ2FuaXphdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBuYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yZ05hbWUnKS52YWx1ZS50cmltKCk7XG4gICAgaWYgKCFuYW1lKSB7IHNob3dOb3RpZmljYXRpb24oJ09yZ2FuaXphdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicsICdlcnJvcicpOyByZXR1cm47IH1cbiAgICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbmNyZW1lbnRhbCBpZCBmb3IgZWFjaCBuZXcgb3JnYW5pemF0aW9uXG4gICAgbGV0IGxhc3RPcmdJZCA9IE51bWJlcihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGFzdE9yZ0lkJykgfHwgJzAnKTtcbiAgICBjb25zdCBuZXdPcmdJZCA9IGxhc3RPcmdJZCArIDE7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xhc3RPcmdJZCcsIG5ld09yZ0lkKTtcbiAgICAvLyBCdWlsZCByZXF1ZXN0IGJvZHkgZm9yIGJhY2tlbmQ6IGZ1bGwgVGVuYW50IG9iamVjdCBpbnNpZGUgMC52YWx1ZVxuICAgIGNvbnN0IHBhcmVudElkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTkpICsgMTsgLy8gMSB0byA5OVxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAwOiB7IHZhbHVlOiBuYW1lIH0sXG4gICAgICAxOiB7IHZhbHVlOiBwYXJlbnRJZCB9LFxuICAgICAgMjogeyB2YWx1ZTogTnVtYmVyKGN1cnJlbnRVc2VySWQpIH0sXG4gICAgICAzOiB7IHZhbHVlOiBcInRydWVcIiB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL0RlcGxveW1lbnRNYW5hZ2VyL2NyZWF0ZVRlbmFudFNpbXBsZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgb3JnYW5pemF0aW9uJyk7XG4gICAgICBzaG93Tm90aWZpY2F0aW9uKGBPcmdhbml6YXRpb24gXFxcIiR7bmFtZX1cXFwiIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IWApO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yZ05hbWUnKS52YWx1ZSA9ICcnO1xuICAgICAgY2xvc2VNb2RhbCgnb3JnLW1vZGFsJywgeyB0YXJnZXQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcmctbW9kYWwnKSB9KTtcbiAgICAgIHJlbmRlck9yZ2FuaXphdGlvbnMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzaG93Tm90aWZpY2F0aW9uKCdGYWlsZWQgdG8gY3JlYXRlIG9yZ2FuaXphdGlvbicsICdlcnJvcicpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQb3B1bGF0ZSB0ZW5hbnQgZHJvcGRvd24gaW4gc2VydmljZSBtb2RhbFxuICBmdW5jdGlvbiBwb3B1bGF0ZVRlbmFudERyb3Bkb3duKG9yZ2FuaXphdGlvbnMgPSBbXSkge1xuICAgIGNvbnN0IHNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZW5hbnRTZWxlY3Rpb24nKTtcbiAgICBpZiAoIXNlbGVjdCkgcmV0dXJuO1xuICAgIGxldCBvcHRpb25zID0gJzxvcHRpb24gdmFsdWU9XCJcIj5ObyBvcmdhbml6YXRpb25zIGF2YWlsYWJsZTwvb3B0aW9uPic7XG4gICAgaWYgKG9yZ2FuaXphdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgb3B0aW9ucyA9ICc8b3B0aW9uIHZhbHVlPVwiX19wZXJzb25hbF9fXCI+VXNlIG15IHBlcnNvbmFsIHRlbmFudDwvb3B0aW9uPic7XG4gICAgICBvcHRpb25zICs9IG9yZ2FuaXphdGlvbnMubWFwKG9yZyA9PiBgPG9wdGlvbiB2YWx1ZT1cIiR7b3JnLnRlbmFudElkfVwiPiR7b3JnLm5hbWV9PC9vcHRpb24+YCkuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSAnPG9wdGlvbiB2YWx1ZT1cIl9fcGVyc29uYWxfX1wiPlVzZSBteSBwZXJzb25hbCB0ZW5hbnQ8L29wdGlvbj4nO1xuICAgIH1cbiAgICBzZWxlY3QuaW5uZXJIVE1MID0gb3B0aW9ucztcbiAgfVxuXG4gIC8vIEZldGNoIHNlcnZpY2VzIGZyb20gYmFja2VuZFxuICBhc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZpY2VzKHVzZXJJZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvQnVpbGRlclNlcnZpY2UvZ2V0QWxsSW5kZXNpZ25TZXJ2aWNlc09mVXNlcj8wPScgKyBlbmNvZGVVUklDb21wb25lbnQodXNlcklkKSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzZXJ2aWNlcycpO1xuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzaG93Tm90aWZpY2F0aW9uKCdGYWlsZWQgdG8gZmV0Y2ggc2VydmljZXMnLCAnZXJyb3InKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW5kZXIgc2VydmljZXNcbiAgYXN5bmMgZnVuY3Rpb24gcmVuZGVyU2VydmljZXMoKSB7XG4gICAgY29uc3Qgc2VydmljZUxpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VydmljZUxpc3QnKTtcbiAgICBjb25zdCBzZXJ2aWNlcyA9IGF3YWl0IGZldGNoU2VydmljZXMoY3VycmVudFVzZXJJZCk7XG4gICAgc2VydmljZUxpc3QuaW5uZXJIVE1MID0gc2VydmljZXMubGVuZ3RoID4gMFxuICAgICAgPyBzZXJ2aWNlcy5tYXAoc3J2ID0+IGA8ZGl2IGNsYXNzPVwic2VydmljZS1pdGVtXCIgb25jbGljaz1cInNlbGVjdEl0ZW0oJ1NlcnZpY2UnLCAnJHtzcnYuc2VydmljZU5hbWV9JylcIj48aDQ+JHtzcnYuc2VydmljZU5hbWV9PC9oND48cCBzdHlsZT1cIm1hcmdpbjowO2NvbG9yOnZhcigtLXRleHQtc2Vjb25kYXJ5KTtmb250LXNpemU6MC45cmVtO1wiPlZlcnNpb246IHYxLjAuMDwvcD48L2Rpdj5gKS5qb2luKCcnKVxuICAgICAgOiBgPHA+Tm8gc2VydmljZXMgZm91bmQuIENyZWF0ZSBvbmUgdG8gZ2V0IHN0YXJ0ZWQuPC9wPmA7XG4gIH1cblxuICAvLyBDcmVhdGUgc2VydmljZSAoaW1wbGVtZW50IGFzIG5lZWRlZClcbiAgd2luZG93LmNyZWF0ZVNlcnZpY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc2VydmljZU5hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VydmljZU5hbWUnKS52YWx1ZS50cmltKCk7XG4gICAgY29uc3QgdGVuYW50U2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RlbmFudFNlbGVjdGlvbicpO1xuICAgIGNvbnN0IHRlbmFudElkID0gdGVuYW50U2VsZWN0ID8gdGVuYW50U2VsZWN0LnZhbHVlIDogJyc7XG4gICAgaWYgKCFzZXJ2aWNlTmFtZSkge1xuICAgICAgc2hvd05vdGlmaWNhdGlvbignU2VydmljZSBuYW1lIGlzIHJlcXVpcmVkLicsICdlcnJvcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdXNlcklkVG9TZW5kID0gdGVuYW50SWQ7XG4gICAgaWYgKCF0ZW5hbnRJZCB8fCB0ZW5hbnRJZCA9PT0gJ19fcGVyc29uYWxfXycpIHtcbiAgICAgIHVzZXJJZFRvU2VuZCA9IGN1cnJlbnRVc2VySWQ7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAwOiB7IHZhbHVlOiBzZXJ2aWNlTmFtZSB9LFxuICAgICAgMTogeyB2YWx1ZTogdXNlcklkVG9TZW5kIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvQnVpbGRlclNlcnZpY2UvY3JlYXRlSW5kZXNpZ25TZXJ2aWNlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXJ2aWNlJyk7XG4gICAgICBzaG93Tm90aWZpY2F0aW9uKGBTZXJ2aWNlIFxcXCIke3NlcnZpY2VOYW1lfVxcXCIgY3JlYXRlZCBzdWNjZXNzZnVsbHkhYCk7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VydmljZU5hbWUnKS52YWx1ZSA9ICcnO1xuICAgICAgY2xvc2VNb2RhbCgnc2VydmljZS1tb2RhbCcsIHsgdGFyZ2V0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VydmljZS1tb2RhbCcpIH0pO1xuICAgICAgcmVuZGVyU2VydmljZXMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzaG93Tm90aWZpY2F0aW9uKCdGYWlsZWQgdG8gY3JlYXRlIHNlcnZpY2UnLCAnZXJyb3InKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VsZWN0IGl0ZW1cbiAgd2luZG93LnNlbGVjdEl0ZW0gPSAodHlwZSwgbmFtZSkgPT4geyBzaG93Tm90aWZpY2F0aW9uKGBTZWxlY3RlZCAke3R5cGV9OiAke25hbWV9YCk7IH07XG5cbiAgLy8gSW5pdGlhbCByZW5kZXJcbiAgcmVuZGVyT3JnYW5pemF0aW9ucygpO1xuICByZW5kZXJTZXJ2aWNlcygpO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/dashboard.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/dashboard.js"]();
/******/ 	
/******/ })()
;